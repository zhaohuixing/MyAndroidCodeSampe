package com.xingzhaohui.xingtest.mainmodule.model;

/**
 * Created by zhaohuixing on 2017-03.
 */
import android.content.Context;
import android.content.ContentValues;
import android.database.Cursor;
import android.database.sqlite.SQLiteDatabase;
import java.util.*;

import com.xingzhaohui.xingtest.mainmodule.data.ScheduleRecord;


public class AppScheduleDBProvider extends AppDataBaseProvider {
    // Database Version
    private static final int SCHEDULEDB_VERSION = 1;

    // Database Name
    private static final String SCHEDULEDB_NAME = "xappschedule";

    // Schedule table name
    private static final String SCHEDULEDB_TABLE = "xschedules";

    // Schedule Table Columns names
    private static final String KEY_ID = "id";  //for m_ScdeduleID
    private static final String KEY_YEAR = "year"; //for m_ScdeduleYear
    private static final String KEY_MONTH = "month"; //for m_ScdeduleMonth
    private static final String KEY_DAY = "day"; //for m_ScdeduleDay
    private static final String KEY_HOUR = "hour"; //for m_ScdeduleHour
    private static final String KEY_MINUTE = "minute"; //for m_ScdeduleMinute
    private static final String KEY_LAST = "last"; //for m_ScdeduleTimeLast
    private static final String KEY_CUSTOMERID = "customerid"; //for m_ScdeduleCustomerID
    private static final String KEY_CUSTOMERNAME = "customername"; //for m_ScdeduleCustomerName
    private static final String KEY_LOCATION = "location"; //for m_ScdeduleLocation
    private static final String KEY_NOTE = "note"; //for m_ScdeduleNote

    public AppScheduleDBProvider(Context context, SQLiteDatabase.CursorFactory factory) {
        super(context, SCHEDULEDB_NAME, SCHEDULEDB_TABLE, SCHEDULEDB_VERSION, factory);
    }

    // Creating Tables
    @Override
    public void onCreate(SQLiteDatabase db) {
        String CREATE_SCHEDULE_TABLE = "CREATE TABLE " + SCHEDULEDB_TABLE + "("
                + KEY_ID + " INTEGER PRIMARY KEY,"
                + KEY_YEAR + " INTEGER,"
                + KEY_MONTH + " INTEGER,"
                + KEY_DAY + " INTEGER,"
                + KEY_HOUR + " INTEGER,"
                + KEY_MINUTE + " INTEGER,"
                + KEY_LAST + " INTEGER,"
                + KEY_CUSTOMERID + " INTEGER,"
                + KEY_CUSTOMERNAME + " TEXT,"
                + KEY_LOCATION + " TEXT,"
                + KEY_NOTE + " TEXT"
                + ")"  ;
        db.execSQL(CREATE_SCHEDULE_TABLE);
    }

    public void addSchedule(ScheduleRecord schedule) {
        SQLiteDatabase db = this.getWritableDatabase();

        ContentValues values = new ContentValues();
        //values.put(KEY_ID, AppDataBaseProvider.CreateGenericIntegerKey()); // Customer ID generated by DB self
        values.put(KEY_YEAR, schedule.m_ScdeduleYear);
        values.put(KEY_MONTH, schedule.m_ScdeduleMonth);
        values.put(KEY_DAY, schedule.m_ScdeduleDay);
        values.put(KEY_HOUR, schedule.m_ScdeduleHour);
        values.put(KEY_MINUTE, schedule.m_ScdeduleMinute);
        values.put(KEY_LAST, schedule.m_ScdeduleTimeLast);
        values.put(KEY_CUSTOMERID, schedule.m_ScdeduleCustomerID);
        values.put(KEY_CUSTOMERNAME, schedule.m_ScdeduleCustomerName);
        values.put(KEY_LOCATION, schedule.m_ScdeduleLocation);
        values.put(KEY_NOTE, schedule.m_ScdeduleNote);

        // Inserting Row
        db.insert(SCHEDULEDB_TABLE, null, values);
        db.close(); // Closing database connection
    }

    public void deleteSchedule(ScheduleRecord schedule) {
        SQLiteDatabase db = this.getWritableDatabase();
        db.delete(SCHEDULEDB_TABLE, KEY_ID + " = ?",
                new String[] { String.valueOf(schedule.m_ScdeduleID) });
        db.close();
    }

    public void deleteSchedule(int id) {
        SQLiteDatabase db = this.getWritableDatabase();
        db.delete(SCHEDULEDB_TABLE, KEY_ID + " = ?",
                new String[] { String.valueOf(id) });
        db.close();
    }

    public int updateSchedule(ScheduleRecord schedule) {
        SQLiteDatabase db = this.getWritableDatabase();

        ContentValues values = new ContentValues();
        values.put(KEY_YEAR, schedule.m_ScdeduleYear);
        values.put(KEY_MONTH, schedule.m_ScdeduleMonth);
        values.put(KEY_DAY, schedule.m_ScdeduleDay);
        values.put(KEY_HOUR, schedule.m_ScdeduleHour);
        values.put(KEY_MINUTE, schedule.m_ScdeduleMinute);
        values.put(KEY_LAST, schedule.m_ScdeduleTimeLast);
        values.put(KEY_CUSTOMERID, schedule.m_ScdeduleCustomerID);
        values.put(KEY_CUSTOMERNAME, schedule.m_ScdeduleCustomerName);
        values.put(KEY_LOCATION, schedule.m_ScdeduleLocation);
        values.put(KEY_NOTE, schedule.m_ScdeduleNote);

        // updating row
        return db.update(SCHEDULEDB_TABLE, values, KEY_ID + " = ?", new String[] { String.valueOf(schedule.m_ScdeduleID) });
    }

    public ScheduleRecord getSchedule(int id) {
        SQLiteDatabase db = this.getReadableDatabase();

        Cursor cursor = db.query(SCHEDULEDB_TABLE,
                new String[] { KEY_ID, KEY_YEAR, KEY_MONTH, KEY_DAY, KEY_HOUR, KEY_MINUTE, KEY_LAST, KEY_CUSTOMERID, KEY_CUSTOMERNAME, KEY_LOCATION, KEY_NOTE},
                KEY_ID + "=?", new String[] { String.valueOf(id) },
                null, null, null, null);
        if (cursor != null)
            cursor.moveToFirst();

        ScheduleRecord schedule = new ScheduleRecord();
        schedule.m_ScdeduleID = Integer.parseInt(cursor.getString(0));
        schedule.m_ScdeduleYear = Integer.parseInt(cursor.getString(1));
        schedule.m_ScdeduleMonth = Integer.parseInt(cursor.getString(2));
        schedule.m_ScdeduleDay = Integer.parseInt(cursor.getString(3));
        schedule.m_ScdeduleHour = Integer.parseInt(cursor.getString(4));
        schedule.m_ScdeduleMinute = Integer.parseInt(cursor.getString(5));
        schedule.m_ScdeduleTimeLast = Integer.parseInt(cursor.getString(6));
        schedule.m_ScdeduleCustomerID = Integer.parseInt(cursor.getString(7));
        schedule.m_ScdeduleCustomerName = cursor.getString(8);
        schedule.m_ScdeduleLocation = cursor.getString(9);
        schedule.m_ScdeduleNote = cursor.getString(10);

        return schedule;
    }

    public List<ScheduleRecord> getAllScheduleList() {
        List<ScheduleRecord> scheduleList = new ArrayList<ScheduleRecord>();

        String selectQuery = "SELECT  * FROM " + SCHEDULEDB_TABLE;

        SQLiteDatabase db = this.getReadableDatabase();
        Cursor cursor = db.rawQuery(selectQuery, null);
        if (cursor.moveToFirst()) {
            do {
                ScheduleRecord schedule = new ScheduleRecord();
                schedule.m_ScdeduleID = Integer.parseInt(cursor.getString(0));
                schedule.m_ScdeduleYear = Integer.parseInt(cursor.getString(1));
                schedule.m_ScdeduleMonth = Integer.parseInt(cursor.getString(2));
                schedule.m_ScdeduleDay = Integer.parseInt(cursor.getString(3));
                schedule.m_ScdeduleHour = Integer.parseInt(cursor.getString(4));
                schedule.m_ScdeduleMinute = Integer.parseInt(cursor.getString(5));
                schedule.m_ScdeduleTimeLast = Integer.parseInt(cursor.getString(6));
                schedule.m_ScdeduleCustomerID = Integer.parseInt(cursor.getString(7));
                schedule.m_ScdeduleCustomerName = cursor.getString(8);
                schedule.m_ScdeduleLocation = cursor.getString(9);
                schedule.m_ScdeduleNote = cursor.getString(10);
                // Adding contact to list
                scheduleList.add(schedule);
            } while (cursor.moveToNext());
        }

        return scheduleList;
    }


    public List<ScheduleRecord> getMonthScheduleList(int nYear, int nMonth) {
        List<ScheduleRecord> scheduleList = new ArrayList<ScheduleRecord>();
        SQLiteDatabase db = this.getReadableDatabase();
/*
        Cursor cursor = db.query(SCHEDULEDB_TABLE,
                new String[] { KEY_ID, KEY_YEAR, KEY_MONTH, KEY_DAY, KEY_HOUR, KEY_MINUTE, KEY_LAST, KEY_CUSTOMERID, KEY_CUSTOMERNAME, KEY_LOCATION, KEY_NOTE},
                KEY_YEAR + "= AND " + KEY_MONTH + "=", new String[] { String.valueOf(nYear),  String.valueOf(nMonth)},
                null, null, null, null);
*/
        String selectQuery = "SELECT * FROM " + SCHEDULEDB_TABLE + " WHERE " + KEY_YEAR +"=" + String.valueOf(nYear) + " AND " + KEY_MONTH +"=" + String.valueOf(nMonth);
        Cursor cursor = db.rawQuery(selectQuery, null);

        if (cursor.moveToFirst()) {
            do {
                ScheduleRecord schedule = new ScheduleRecord();
                schedule.m_ScdeduleID = Integer.parseInt(cursor.getString(0));
                schedule.m_ScdeduleYear = Integer.parseInt(cursor.getString(1));
                schedule.m_ScdeduleMonth = Integer.parseInt(cursor.getString(2));
                schedule.m_ScdeduleDay = Integer.parseInt(cursor.getString(3));
                schedule.m_ScdeduleHour = Integer.parseInt(cursor.getString(4));
                schedule.m_ScdeduleMinute = Integer.parseInt(cursor.getString(5));
                schedule.m_ScdeduleTimeLast = Integer.parseInt(cursor.getString(6));
                schedule.m_ScdeduleCustomerID = Integer.parseInt(cursor.getString(7));
                schedule.m_ScdeduleCustomerName = cursor.getString(8);
                schedule.m_ScdeduleLocation = cursor.getString(9);
                schedule.m_ScdeduleNote = cursor.getString(10);
                // Adding contact to list
                scheduleList.add(schedule);
            } while (cursor.moveToNext());
        }

        return scheduleList;
    }

    public List<ScheduleRecord> getDayScheduleList(int nYear, int nMonth, int nDay) {
        List<ScheduleRecord> scheduleList = new ArrayList<ScheduleRecord>();
        SQLiteDatabase db = this.getReadableDatabase();

        Cursor cursor = db.query(SCHEDULEDB_TABLE,
                new String[] { KEY_ID, KEY_YEAR, KEY_MONTH, KEY_DAY, KEY_HOUR, KEY_MINUTE, KEY_LAST, KEY_CUSTOMERID, KEY_CUSTOMERNAME, KEY_LOCATION, KEY_NOTE},
                KEY_YEAR + "=? AND " + KEY_MONTH + "=? AND " + KEY_DAY + "=?", new String[] { String.valueOf(nYear),  String.valueOf(nMonth), String.valueOf(nDay)},
                null, null, null, null);

        if (cursor.moveToFirst()) {
            do {
                ScheduleRecord schedule = new ScheduleRecord();
                schedule.m_ScdeduleID = Integer.parseInt(cursor.getString(0));
                schedule.m_ScdeduleYear = Integer.parseInt(cursor.getString(1));
                schedule.m_ScdeduleMonth = Integer.parseInt(cursor.getString(2));
                schedule.m_ScdeduleDay = Integer.parseInt(cursor.getString(3));
                schedule.m_ScdeduleHour = Integer.parseInt(cursor.getString(4));
                schedule.m_ScdeduleMinute = Integer.parseInt(cursor.getString(5));
                schedule.m_ScdeduleTimeLast = Integer.parseInt(cursor.getString(6));
                schedule.m_ScdeduleCustomerID = Integer.parseInt(cursor.getString(7));
                schedule.m_ScdeduleCustomerName = cursor.getString(8);
                schedule.m_ScdeduleLocation = cursor.getString(9);
                schedule.m_ScdeduleNote = cursor.getString(10);
                // Adding contact to list
                scheduleList.add(schedule);
            } while (cursor.moveToNext());
        }

        return scheduleList;
    }

    public interface IScheduleDBActionHandler {
        void onScheduleRecordDeleted(boolean bResult);
    }
}
/*
public class DeleteScheduleTask extends AsyncTask<Void, Void, Boolean> {
    AppScheduleDBProvider.IScheduleDBActionHandler m_Handler;
    AppScheduleDBProvider           m_DBEnginer;
    int                             m_nRecordID;

    public DeleteScheduleTask(AppScheduleDBProvider.IScheduleDBActionHandler handler, AppScheduleDBProvider db, int nRecordID) {
        m_Handler = handler;
        m_DBEnginer = db;
        m_nRecordID = nRecordID;
    }

    protected Boolean doInBackground(Void...voids)
    {
        boolean bRet = false;

        if(m_DBEnginer != null) {
            m_DBEnginer.deleteSchedule(m_nRecordID);
            bRet = true;
        }

        return bRet;
    }

    protected void onPostExecute(Boolean result)
    {
        if(m_Handler != null) {
            m_Handler.onScheduleRecordDeleted(result);
        }
    }
}
*/